基础篇
谈谈对java多态的理解？
可供参考：

多态就是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定，即一个引用变量倒底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。因为在程序运行时才确定具体的类，这样，不用修改源程序代码，就可以让引用变量绑定到各种不同的类实现上，从而导致该引用调用的具体方法随之改变，即不修改程序代码就可以改变程序运行时所绑定的具体代码，让程序可以选择多个运行状态，这就是多态性。

面试考察：候选人对java继承、接口等的定义的理解，候选人实际编写接口、抽象类代码

int与integer的区别？
- Integer是int的包装类，int则是java的一种基本数据类型 

- Integer变量必须实例化后才能使用，而int变量不需要 

- Integer实际是对象的引用，当new一个Integer时，实际上是生成一个指针指向此对象；而int则是直接存储数据值 

- Integer的默认值是null，int的默认值是0

面试考察：候选人对java基本数据类型的列举&使用，候选人对java包装类的认知

String、StringBuffer、StringBuilder区别？
- StringBuffer算是String的敷生的一个类，而StringBuilder却又是Oracle公司为了减少线程开销，而诞生的一个类。(这个区别有点扯….)

- 字符串的主要操作还是String，StringBuffer与StringBuilder主要还是用来拼接字符串的。

- StringBuffer与StringBuilder的长度是可以定义的，而String不能(因为String是个对象)。

- 三者主要用的地方都不一样：

    String：它被用于裁剪，拼接。(当然如果拼接过多的话还是建议用StringBuffer,或者StringBuild)搜索字符串，比较字符串，截取字符串，转换大小写等。在项目中不经常发生变化的业务场景中，优先使用String

    StringBuffer：用于拼接，替换，删除。在项目多线程环境下运行，如:XML解析，HTTP参数解析与封装等。

    StringBuilder:它同StringBuffer使用方式一样，不过在项目中使用的地方建议是单线程的环境下，如：SQL拼接，JSON封装等。
面试考察：候选人对java中字符串相关应用的知识的掌握


final，finally，finalize的区别？
- final用于声明属性，方法和类，分别表示属性不可交变，方法不可覆盖，类不可继承。
- finally是异常处理语句结构的一部分，表示总是执行。
- finalize是Object类的一个方法，在垃圾收集器执行的时候会调用被回收对象的此方法，供垃圾收集时的其他资源回收，例如关闭文件等。

面试考察：候选人对这三个概念的了解，各自的使用场景

强引用、软引用、弱引用、幻想引用有什么区别？
- 强引用就是我们常见的创建对象实例的时候就是new的过程，只要他还指向一个对象，就表明他还活着，垃圾收集器就不会碰如果没有其他的引用关系，或者将其显示的赋值为null，就可以被回收。

- 软引用可以豁免一些垃圾回收，只有当jvm认为内存不足的才会试图回收引用所指向的对象，jvm在确保抛出oom时，会清理软引用指向的对象，通常用来实现内存敏感的缓存，如果还有空闲内存，就暂时保留缓存，当内存不足时清理掉，这样就保证了使用缓存的同时，不会耗尽内存。

- 弱引用并不能是对象豁免垃圾收集，仅仅是提供了一种访问弱引用下对象的途径。可以用来构建一种没有特定约束的关系，比如，维护一种非强制的映射关系，如果获取是还在就是用它，否则实例化。

- 幻想引用不能通过他访问对象，仅仅提供一种确保对象被finalize以后，做某些事情的机制，比如post-mortem清理机制
面试考察：候选人对这些概念的知识掌握，考察候选人的知识深度

对比HashTable、HashMap、TreeMap有什么不同？
- Hashtable、HashMap、TreeMap都实现了Map接口，使用键值对的形式存储数据和操作数据。
- Hashtable是java早期提供的，方法是同步的（加了synchronized）。key和value都不能是null值。
- HashMap的方法不是同步的，支持key和value为null的情况。行为上基本和Hashtable一致。由于Hashtable是同步的，性能开销比较大，一般不推荐使用Hashtable。通常会选择使用HashMap。
- HashMap进行put和get操作，基本上可以达到常数时间的性能
- TreeMap是基于红黑树的一种提供顺序访问的Map，和HashMap不同，它的get或put操作的时间复杂度是O(log(n))。具体的顺序由指定的Comparator来决定，或者根据键key的具体顺序来决定。
面试考察：候选人对java集合类的掌握情况，实际应用情况等

HashMap与HashSet的区别？
*HashMap*	*HashSet*
HashMap实现了Map接口	HashSet实现了Set接口
HashMap储存键值对	HashSet仅仅存储对象
使用put()方法将元素放入map中	使用add()方法将元素放入set中
HashMap中使用键对象来计算hashcode值	HashSet使用成员对象来计算hashcode值，对于两个对象来说hashcode可能相同，所以equals()方法用来判断对象的相等性，如果两个对象不同的话，那么返回false
HashMap比较快，因为是使用唯一的键来获取对象	HashSet较HashMap来说比较慢
面试考察：候选人对java集合类的掌握深度

谈谈接口和抽象类有什么区别？
参数	抽象类	接口
默认的方法实现	它可以有默认的方法实现	接口完全是抽象的。它根本不存在方法的实现
实现	子类使用extends关键字来继承抽象类。如果子类不是抽象类的话，它需要提供抽象类中所有声明的方法的实现。	子类使用关键字implements来实现接口。它需要提供接口中所有声明的方法的实现
构造器	抽象类可以有构造器	接口不能有构造器
与正常Java类的区别	除了你不能实例化抽象类之外，它和普通Java类没有任何区别	接口是完全不同的类型
访问修饰符	抽象方法可以有public、protected和default这些修饰符	接口方法默认修饰符是public。你不可以使用其它修饰符。
main方法	抽象方法可以有main方法并且我们可以运行它	接口没有main方法，因此我们不能运行它。
多继承	抽象方法可以继承一个类和实现多个接口	接口只可以继承一个或多个其它接口
速度	它比接口速度要快	接口是稍微有点慢的，因为它需要时间去寻找在类中实现的方法。
添加新方法	如果你往抽象类中添加新的方法，你可以给它提供默认的实现。因此你不需要改变你现在的代码。	如果你往接口中添加方法，那么你必须改变实现该接口的类。
面试考察：候选人对面向对象编程的理解以及实际工作中的应用


你知道的设计模式有哪些？
单例模式、策略模式、观察者模式、装饰模式、适配器模式、命令模式、组合模式、 简单工厂模式、模板方法模式
饿汉式、懒汉式（线程安全、不安全）、双重锁校验

面试考察：候选人对编程的基本sense

静态属性和静态方法是否可以被继承？是否可以被重写？以及原因？
- 父类的静态属性和方法可以被子类继承

- 不可以被子类重写。

- 原因：
1). 静态方法和属性是属于类的，调用的时候直接通过类名.方法名完成对，不需要继承机制及可以调用。如果子类里面定义了静态方法和属性，那么这时候父类的静态方法或属性称之为"隐藏"。如果你想要调用父类的静态方法和属性，直接通过父类名.方法或变量名完成，至于是否继承一说，子类是有继承静态方法和属性，但是跟实例方法和属性不太一样，存在"隐藏"的这种情况。
2). 多态之所以能够实现依赖于继承、接口和重写、重载（继承和重写最为关键）。有了继承和重写就可以实现父类的引用指向不同子类的对象。重写的功能是："重写"后子类的优先级要高于父类的优先级，但是“隐藏”是没有这个优先级之分的。

3). 静态属性、静态方法和非静态的属性都可以被继承和隐藏而不能被重写，因此不能实现多态，不能实现父类的引用可以指向不同子类的对象。非静态方法可以被继承和重写，因此可以实现多态。

面试考察：候选人对java面向对象编程特性是否有深入理解

开启线程的三种方式？
- 继承Thread类，新建一个当前类对象，并且运行其start()方法

- 实现Runnable接口，然后新建当前类对象，接着新建Thread对象时把当前类对象传进去，最后运行Thread对象的start()方法

- 实现Callable接口，新建当前类对象，在新建FutureTask类对象时传入当前类对象，接着新建Thread类对象时传入FutureTask类对象，最后运行Thread对象的start()方法

面试考察：候选人对java多线程编程的了解、候选人是否review过开发相关代码、候选人对多线程类被测系统如何测试等


synchronized与Lock的区别
- 首先synchronized是java内置关键字，在jvm层面，Lock是个java类；

- synchronized无法判断是否获取锁的状态，Lock可以判断是否获取到锁；

- synchronized会自动释放锁(a 线程执行完同步代码会释放锁 ；b 线程执行过程中发生异常会释放锁)，Lock需在finally中手工释放锁（unlock()方法释放锁），否则容易造成线程死锁；

- 用synchronized关键字的两个线程1和线程2，如果当前线程1获得锁，线程2线程等待。如果线程1阻塞，线程2则会一直等待下去，而Lock锁就不一定会等待下去，如果尝试获取不到锁，线程可以不用一直等待就结束了；

- synchronized的锁可重入、不可中断、非公平，而Lock锁可重入、可判断、可公平（两者皆可）

- Lock锁适合大量同步的代码的同步问题，synchronized锁适合代码少量的同步问题。
面试考察：候选人对该知识点的掌握情况、java中并发的理解

死锁的四个必要条件？
- 互斥：某种资源一次只允许一个进程访问，即该资源一旦分配给某个进程，其他进程就不能再访问，直到该进程访问结束。
- 占有且等待：一个进程本身占有资源（一种或多种），同时还有资源未得到满足，正在等待其他进程释放该资源。
- 不可抢占：别人已经占有了某项资源，你不能因为自己也需要该资源，就去把别人的资源抢过来。
- 循环等待：存在一个进程链，使得每个进程都占有下一个进程所需的至少一种资源。
当以上四个条件均满足，必然会造成死锁，发生死锁的进程无法进行下去，它们所持有的资源也无法释放。这样会导致CPU的吞吐量下降。所以死锁情况是会浪费系统资源和影响计算机的使用性能的。那么，解决死锁问题就是相当有必要的了。

面试考察：候选人对死锁的理解、实际工作中遇到的死锁情况、如何测试
ReentrantLock 、synchronized和volatile的区别?
volatile和synchronized的区别：
- volatile本质是在告诉jvm当前变量在寄存器（工作内存）中的值是不确定的，需要从主存中读取； synchronized则是锁定当前变量，只有当前线程可以访问该变量，其他线程被阻塞住。
- volatile仅能使用在变量级别；synchronized则可以使用在变量、方法、和类级别的
- volatile仅能实现变量的修改可见性，不能保证原子性；而synchronized则可以保证变量的修改可见性和原子性
- volatile不会造成线程的阻塞；synchronized可能会造成线程的阻塞。
- volatile标记的变量不会被编译器优化；synchronized标记的变量可以被编译器优化

Synchronized 和 ReentrantLock 的区别：
- ReentrantLock功能性方面更全面，比如时间锁等候，可中断锁等候，锁投票等，因此更有扩展性。在多个条件变量和高度竞争锁的地方，用ReentrantLock更合适，ReentrantLock还提供了Condition，对线程的等待和唤醒等操作更加灵活，一个ReentrantLock可以有多个Condition实例，所以更有扩展性。
- ReentrantLock必须在finally中释放锁，否则后果很严重，编码角度来说使用synchronized更加简单，不容易遗漏或者出错。
- ReentrantLock 的性能比synchronized会好点。
- ReentrantLock提供了可轮询的锁请求，他可以尝试的去取得锁，如果取得成功则继续处理，取得不成功，可以等下次运行的时候处理，所以不容易产生死锁，而synchronized则一旦进入锁请求要么成功，要么一直阻塞，所以更容易产生死锁。

面试考察：候选人对这三个概念的掌握深度
高级篇
哪些情况下的对象会被垃圾回收机制处理掉？
GC可以判断哪些对象时可以被回收而哪些是不能被回收的，常见的两种判断方法：

- 引用计数法

这种方法是在对象的头处维护一个计数器Counter，当有一个引用指向对象的时候counter就加一，当不在引用此对象时就让counter减一。所以，当counter等于零的时候虚拟机就认为此对象时可以被回收的。

- 可达性分析算法

Java就是使用此方法作为判断对象是否可被回收的。虚拟机会先将一些对象定义为GC Roots，从GC Roots出发一直沿着引用链向下寻找，如果某个对象不能通过GC Roots寻找到，那么虚拟机就认为该对象可以被回收。

面试考察：候选人对主流jvm实现的垃圾回收机制的知识的了解、实际工作中遇到的内存泄漏问题等

Java并发类库提供的线程池有哪几种？分别有什么特点？
- newCachedThreadPool（），它是用来处理大量短时间工作任务的线程池，具有几个鲜明特点：它会试图缓存线程并重用，当无缓存线程可用时，就会创建新的工作线程；如果线程闲置时间超过60秒，则被终止并移除缓存；长时间闲置时，这种线程池，不会消耗什么资源。其内部使用SynchronousQueue作为工作队列。

- newFixedThreadPool（int nThreads），重用指定数目（nThreads）的线程，其背后使用的是无界的工作队列，任何时候最多有nThreads个工作线程是活动的。这意味着，如果任务数量超过了活动线程数目，将在工作队列中等待空闲线程出现；如果工作线程退出，将会有新的工作线程被创建，以补足指定数目nThreads。

- newSingleThreadExecutor()，它的特点在于工作线程数目限制为1，操作一个无界的工作队列，所以它保证了所有的任务都是被顺序执行，最多会有一个任务处于活动状态，并且不予许使用者改动线程池实例，因此可以避免改变线程数目。

- newSingleThreadScheduledExecutor()和newScheduledThreadPool(int corePoolSize)，创建的是个ScheduledExecutorService，可以进行定时或周期性的工作调度，区别在于单一工作线程还是多个工作线程。

- newWorkStealingPool(int parallelism)，这是一个经常被人忽略的线程池，Java 8 才加入这个创建方法，其内部会构建ForkJoinPool，利用Work-Stealing算法，并行地处理任务，不保证处理顺序。

面试考察：候选人对java并发的定义等知识的了解、实际工作中遇到的并发问题等

synchronized底层如何实现？什么是锁的升级、降级？
synchronized 代码块是由一对儿 monitorenter/monitorexit 指令实现的，Monitor 对象是同步的基本实现单元。

在 Java 6 之前，Monitor 的实现完全是依靠操作系统内部的互斥锁，因为需要进行用户态到内核态的切换，所以同步操作是一个无差别的重量级操作。

现代的（Oracle）JDK 中，JVM 对此进行了大刀阔斧地改进，提供了三种不同的Monitor 实现，也就是常说的三种不同的锁：偏斜锁（Biased Locking）、轻量级锁和重量级锁，大大改进了其性能。

所谓锁的升级、降级，就是 JVM 优化 synchronized 运行的机制，当 JVM 检测到不同的竞争状况时，会自动切换到适合的锁实现，这种切换就是锁的升级、降级。

锁的升级：偏斜锁==>轻量级锁==>重量级锁
锁的降级：重量级锁==>轻量级锁==>偏斜锁

面试考察：候选人对synchronized的了解、实际工作中遇到的synchronized修饰的代码的作用等
如何监控和诊断JVM堆内和堆外内存使用？
- 使用综合性的图形化工具，如JConsole、VisualVM(从Oracle JDK9开始，VisualVM已经不再包含在JDK安装包中)等。这些工具具体使用起来相对比较直观，直接连接到Java进程，然后就可以在图形化界面里掌握内存使用情况。

- 也可以使用jmap等提供的命令，生成堆转储（Heap Dump）文件，然后利用jhat或Eclipse MAT等堆转储分析工具进行详细分析。

- 也可以使用命令行工具进行运行时查询，如jstat和jmap等工具都提供了一些选项，可以查看堆、方法区等使用数据。
面试考察：候选人对主流jvm实现的了解、实际工作中涉及到jvm调优的例子

谈谈你的GC调优思路？

from 《Java Performance》
- 首先需要测试程序的性能基准数据
- 其次，需要制定性能目标，一般可以对标竞品，可参考步骤一的baseline数据、本公司的业务需求、线上服务器、网络架构、部署模式等等
- 然后继续性能测试，提高被测系统压力
- 收集步骤三中出现的性能问题，并解决
- 循环步骤三和步骤四，直至达到本次性能调优的目标性能指标
面试考察：候选人是否做过性能测试、性能调优思路、遇到过的实际性能问题并如何定位等
什么情况下Java程序会产生死锁？如何定位、修复？
可供参考：
- 死锁是由于多个对象或多个线程之间相互需要对方锁持有的锁而又没有释放对方所持有的锁，导致双方都永久处于阻塞状态
- 需要找出哪里出现了死锁，通过代码走查通常不容易发现死锁，当然我们这程序很容易发现，因为我们刻意产生的死锁；所以就需要工具来检测死锁，这里可用的工具主要有：jconsole、jvisualvm、jstack等，这些工具其实都是jdk自带的，用法都很类似；
- 使用jvisualvm来检测当前的demo程序是否产生了死锁；打开jvisualvm连接到当前的应用程序即可看到程序的监控信息，如内存、CPU、性能、GC等等；打开进入线程的tab项查看程序的线程信息
- 除了发现程序出现问题后我们去扫描死锁外，我们还可以实时的去扫描程序用于发现程序中是否存在死锁；
- JDK提供了MXBean Api可用于扫描程序是否存在死锁，ThreadMXBean提供了findDeadlockedThreads()方法，可以用于找到产生死锁的线程；这里在上面的demo程序中添加一个方法用于扫描死锁，虽然这种方法可以扫描到死锁但是由于每次都对线程打快照对程序性能会有比较大的影响，所以慎用；
- 解决死锁最好的方法就是避免死锁了，比如上面的demo我们可以把直接使用无参数的lock()方法换为使用tryLock方法，tryLock还可以指定获取锁超时时间，到了超时时间还没获得到锁就会放弃获取锁，当然还有其它方法可以避免死锁；
     – 避免使用多个锁、长时间持有锁；
　– 设计好多个锁的获取顺序
  – 使用带超时的获取锁方法
面试考察：候选人对死锁的定义的理解，实际工作中遇到的死锁问题，如何测试是否存在死锁
说说你对Java反射的理解？
定义：Java反射说的是在运行状态中，对于任何一个类，我们都能够知道这个类有哪些方法和属性。对于任何一个对象，我们都能够对它的方法和属性进行调用。我们把这种动态获取对象信息和调用对象方法的功能称之为反射机制。
面试考察：候选人对java反射的定义是否了解，实际工作中是否review过开发的反射应用代码、是否亲自编写过使用反射的代码